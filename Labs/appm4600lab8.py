# -*- coding: utf-8 -*-
"""APPM4600Lab8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jEBXLXKUG4MyZcR_Tzl8z7gyPkcnNcjd
"""

import numpy as np

def lin_spline(x0, x1, f, x_eval):

    # Calculate y-coordinates
    y0 = f(x0)
    y1 = f(x1)

    # Calculate slope (m) and y-intercept (b) of the line
    m = (y1 - y0) / (x1 - x0)
    b = y0 - m * x0

    # Evaluate line at x_eval points
    y_eval = m * x_eval + b

    return y_eval


# Define points through which line passes
x0 = 1
x1 = 2

# Define points at which to evaluate the line
x_eval = np.linspace(0, 3, 100)

# Construct and evaluate the line


# Now y_eval contains the y-values of the line evaluated at x_eval points. You can use these values as needed, e.g., for plotting.

import matplotlib.pyplot as plt
import numpy as np
import math
from numpy.linalg import inv

x = np.linspace(0,10,100)
ind = np.where(x<=1)

xeval = np.linspace(0,10,1000) # vector of points where you want to evaluate your piecewise approximation
xint = np.linspace(0,10,11) # denotes the intervals in which you will have piecewise defined polynomial

points_in_subintervals = {i: [] for i in range(1, len(xint))}

# Loop through the subintervals
for i in range(1, len(xint)):
    lower_bound = xint[i - 1]
    upper_bound = xint[i]

    # Find points in xeval that lie within the current subinterval
    points_in_current_subinterval = xeval[(xeval >= lower_bound) & (xeval < upper_bound)]

    # Store these points in the dictionary
    points_in_subintervals[i] = points_in_current_subinterval

import matplotlib.pyplot as plt
import numpy as np
import math
from numpy.linalg import inv


def driver():

    f = lambda x: 1/(1+(10*x)**2)
    a = 0
    b = 10

    ''' create points you want to evaluate at'''
    Neval = 1000
    xeval =  np.linspace(a,b,Neval)
    print(xeval)
    ''' number of intervals'''
    Nint = 10

    '''evaluate the linear spline'''
    yeval = eval_lin_spline(xeval,Neval,a,b,f,Nint)
    print(yeval)
    xint = np.linspace(0,10,11) # denotes the intervals in which you will have piecewise defined polynomial

    points_in_subintervals = {i: [] for i in range(1, len(xint))}

def lin_spline(x0, x1, f, x_eval):

    # Calculate y-coordinates
    y0 = f(x0)
    y1 = f(x1)

    # Calculate slope (m) and y-intercept (b) of the line
    m = (y1 - y0) / (x1 - x0)
    b = y0 - m * x0

    # Evaluate line at x_eval points
    y_eval = m * x_eval + b

    return y_eval


    # Define points through which line passes
    x0 = 1
    x1 = 2

    # Define points at which to evaluate the line
    x_eval = np.linspace(0, 3, 100)

    # Construct and evaluate the line
    y_eval = lin_spline(x0, x1, f, x_eval)


    # Loop through the subintervals
    for i in range(1, len(xint)):
        lower_bound = xint[i - 1]
        upper_bound = xint[i]

    # Find points in xeval that lie within the current subinterval
    points_in_current_subinterval = xeval[(xeval >= lower_bound) & (xeval < upper_bound)]

    # Store these points in the dictionary
    points_in_subintervals[i] = points_in_current_subinterval
    ''' evaluate f at the evaluation points'''
    Neval = 1000
    fex = np.zeros(Neval)
    for j in range(Neval):
      fex[j] = f(xeval[j])


    plt.figure()
    plt.plot(xeval,fex,'ro-')
    plt.plot(xeval,yeval,'bs-')
    plt.legend()
    plt.show

    err = abs(yeval-fex)
    plt.figure()
    plt.plot(xeval,err,'ro-')
    plt.show





def  eval_lin_spline(xeval,Neval,a,b,f,Nint):

    '''create the intervals for piecewise approximations'''
    xint = np.linspace(a,b,Nint+1)

    '''create vector to store the evaluation of the linear splines'''
    yeval = np.zeros(Neval)


    for jint in range(Nint):
        '''find indices of xeval in interval (xint(jint),xint(jint+1))'''
        '''let ind denote the indices in the intervals'''
        '''let n denote the length of ind'''

        '''temporarily store your info for creating a line in the interval of
         interest'''
        a1= xint[jint]
        fa1 = f(a1)
        b1 = xint[jint+1]
        fb1 = f(b1)

        for kk in range(Neval):
           '''use your line evaluator to evaluate the lines at each of the points
           in the interval'''
           '''yeval(ind(kk)) = call your line evaluator at xeval(ind(kk)) with
           the points (a1,fa1) and (b1,fb1)'''

xint = np.linspace(0,10,11) # denotes the intervals in which you will have piecewise defined polynomial

points_in_subintervals = {i: [] for i in range(1, len(xint))}

# Loop through the subintervals
for i in range(1, len(xint)):
    lower_bound = xint[i - 1]
    upper_bound = xint[i]

    # Find points in xeval that lie within the current subinterval
    points_in_current_subinterval = xeval[(xeval >= lower_bound) & (xeval < upper_bound)]

    # Store these points in the dictionary
    points_in_subintervals[i] = points_in_current_subinterval

if __name__ == '__main__':
      # run the drivers only if this is called from the command line
      driver()