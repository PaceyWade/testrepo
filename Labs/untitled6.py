# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18qJPT1EpliY1SgWeH_NPReo6tfiPOh-1

Lagrange works much better with 3, at 5 lagrange is still better, at 7 they are close to the same, at 10 they are very similar, but newton is weird on the ends
"""

import numpy as np
import numpy.linalg as la
import matplotlib.pyplot as plt

def driver():
    f = lambda x: 1/(1+(10*x)**2)

    N = 17 #degree of polynomial you want to approximate
    a, b = -1, 1

    xint = np.linspace(a, b, N+1)
    yint = f(xint)

    Neval = 1000 #how much data you want to have
    xeval = np.linspace(a, b, Neval+1)
    yeval_l = np.zeros(Neval+1)
    yeval_dd = np.zeros(Neval+1)
    yeval_vander = np.zeros(Neval+1)  # For Vandermonde

    y = np.zeros((N+1, N+1))
    for j in range(N+1):
        y[j][0] = yint[j]

    y = dividedDiffTable(xint, y, N+1)

    # Vandermonde matrix method
    V = create_vandermonde(xint, N)
    coeffs_vander = la.solve(V, yint)  # Solve for the coefficients
    for kk in range(Neval+1):
        yeval_vander[kk] = eval_poly(coeffs_vander, xeval[kk])  # Evaluate the polynomial

    for kk in range(Neval+1):
        yeval_l[kk] = eval_lagrange(xeval[kk], xint, yint, N)
        yeval_dd[kk] = evalDDpoly(xeval[kk], xint, y, N)

    fex = f(xeval)

    plt.figure()
    plt.plot(xeval, fex, 'ro-', label='Exact Function')
    plt.plot(xeval, yeval_l, 'bs--', label='Lagrange')
    plt.plot(xeval, yeval_dd, 'c.--', label='Newton DD')
    plt.plot(xeval, yeval_vander, 'g^--', label='Vandermonde')  # Adding Vandermonde to the plot
    plt.legend()
    plt.title('Function Approximation')
    plt.xlabel('x')
    plt.ylabel('f(x)')

    plt.figure()
    err_l = abs(yeval_l - fex)
    err_dd = abs(yeval_dd - fex)
    err_vander = abs(yeval_vander - fex)  # Error for Vandermonde
    plt.semilogy(xeval, err_l, 'bs--', label='Lagrange Error')
    plt.semilogy(xeval, err_dd, 'c.--', label='Newton DD Error')
    plt.semilogy(xeval, err_vander, 'g^--', label='Vandermonde Error')  # Adding Vandermonde error to the plot
    plt.legend()
    plt.title('Approximation Error')
    plt.xlabel('x')
    plt.ylabel('Error')
    plt.show()

def create_vandermonde(x, N):
    """Create a Vandermonde matrix given the x coordinates."""
    V = np.zeros((N+1, N+1))
    for i in range(N+1):
        V[i, :] = x[i] ** np.arange(N+1)
    return V

def eval_poly(coeffs, x):
    """Evaluate a polynomial with coefficients 'coeffs' at points 'x'."""
    n = len(coeffs)
    return sum([coeffs[i] * x ** i for i in range(n)])

# ... [rest of your functions, unchanged]

driver()